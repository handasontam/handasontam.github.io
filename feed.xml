<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://handasontam.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://handasontam.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-22T11:05:30+00:00</updated><id>https://handasontam.github.io/feed.xml</id><title type="html">Handason’s Blog</title><subtitle>Handason&apos;s Blog </subtitle><entry><title type="html">Fugitive #1: Tracking the Fugitive with Graph-Based Deduction</title><link href="https://handasontam.github.io/blog/2024/fugitive-marshal/" rel="alternate" type="text/html" title="Fugitive #1: Tracking the Fugitive with Graph-Based Deduction"/><published>2024-10-08T15:09:00+00:00</published><updated>2024-10-08T15:09:00+00:00</updated><id>https://handasontam.github.io/blog/2024/fugitive-marshal</id><content type="html" xml:base="https://handasontam.github.io/blog/2024/fugitive-marshal/"><![CDATA[<p>In the realm of two-player deduction games, “Fugitive” stands out as a thrilling cat-and-mouse chase. One player, the Fugitive, tries to escape by moving through a series of hidden locations, while the other player, the Marshal, attempts to deduce and uncover these hideouts. Today, we’ll dive into a fascinating AI implementation that brings the Marshal’s deductive reasoning to life using graph theory.</p> <p>I recently had the pleasure of playing Fugitive with friends and found it to be an engaging game of strategy and deduction. As someone who enjoys analyzing optimal strategies in games, I was naturally drawn to exploring the strategic depths of Fugitive.</p> <p>In this series of posts, I’ll model the game using graph theory and reinforcement learning techniques. My goal is to uncover optimal strategies for both players and gain insights into the game’s balance.</p> <p>Interestingly, when researching online strategies, I discovered a divide in player opinions regarding which role has an advantage. Some players claim the Marshal can never win (as discussed <a href="https://boardgamegeek.com/thread/2997124/cant-win-as-marshal">here</a>), while others question if the Marshal can lose at all (see <a href="https://boardgamegeek.com/thread/1757632/can-the-marshal-lose">this thread</a>). This disparity in experiences adds an intriguing dimension to our analysis.</p> <h3 id="game-overview">Game Overview</h3> <p>Fugitive is a two-player card game where one player takes on the role of a Fugitive trying to escape, while the other plays as the Marshal attempting to catch them. The game uses a deck of 43 numbered cards (0-42) representing potential hideouts. The Fugitive wins by playing the #42 card, signifying a successful escape, while the Marshal wins by uncovering all of the Fugitive’s hideouts before they can escape.</p> <p>Players take turns, with the Fugitive starting at hideout 0. The Fugitive establishes hideouts by playing cards face-down in ascending order. Each new hideout must be numbered within 1, 2, or 3 of the previous one. To cover larger distances, the Fugitive can “Sprint” by placing additional cards underneath a hideout. These sprint cards have values (+1 or +2) that allow the Fugitive to jump further than the usual 3-card limit.</p> <p>The Marshal attempts to guess and reveal these hideouts. The game’s tension builds as the Fugitive tries to outmaneuver the Marshal, using special “Sprint” moves to cover larger distances, while the Marshal uses deduction and strategy to close in on their target.</p> <h3 id="research-questions">Research Questions</h3> <p>Through this series, we aim to answer the following questions:</p> <ol> <li>How can we optimally take and update notes as the Marshal?</li> <li>What are the optimal strategies for both players? <ul> <li>For the Marshal: <ul> <li>Which deck should the Marshal draw from? Is drawing exclusively from a higher pile to create a ‘roadblock’ useful?</li> <li>Which numbers should the Marshal guess?</li> <li>Should the Marshal guess more than one number?</li> <li>Should the Marshal aim to win by manhunt or by uncovering all hideouts before the Fugitive escapes?</li> </ul> </li> <li>For the Fugitive: <ul> <li>Which hideouts should the Fugitive establish?</li> <li>Which sprints should the Fugitive use?</li> <li>Does bluffing help?</li> </ul> </li> </ul> </li> <li>What are the winning probabilities for both players if they play optimally? This will help us determine if the game is balanced.</li> </ol> <p>In this post, we’ll tackle the first question by exploring an advanced note-taking system for the Marshal using graph-based deduction.</p> <h3 id="the-marshals-dilemma">The Marshal’s Dilemma</h3> <p>Imagine you’re the Marshal. You know the Fugitive started at location 0 and is making their way towards location 42. Each turn, they place a new hideout card face-down, occasionally “sprinting” by adding extra cards to cover larger distances. Your job? Guess these hideouts before the Fugitive reaches their final escape.</p> <p>The challenge lies in efficiently tracking all possible locations for each hideout based on the limited information you receive. This is where our <code class="language-plaintext highlighter-rouge">MarshalNotes</code> class comes in, leveraging a directed graph to model the Marshal’s deductions.</p> <p>This approach will also be useful when we implement the action mask in the reinforcement learning setting for filtering out illegal actions. Consider the action space for the Marshal’s guess:</p> <ol> <li> <p>The Marshal should only guess numbers within the possible range of hideouts. For example, if the Fugitive plays 2 hideouts without sprinting at the start of the game, the Marshal should not guess any number larger than 6.</p> </li> <li> <p>The Marshal must not guess numbers that are in their hand, have already been revealed as hideouts, or used as sprints.</p> </li> <li> <p>The Marshal can avoid guessing numbers that have already been guessed, with one caveat: A wrong guess only reveals that the number is not a hideout among those already placed. It could still be a future hideout.</p> </li> </ol> <p>As the game progresses, the Marshal must keep track of the possible range for each hideout and update this information based on guesses, revealed cards, and drawn cards.</p> <p>Based on the above considerations, the official board game provided a Marshal’s notepad (<a href="https://apps.apple.com/hk/app/fugitive-notepad/id1135595567">example</a>), which consists of a grid of 41 numbers, and the marshal can mark the number that has been known not to be a hideout. This helps the marshal to keep track of the potential hideouts. However, we can do much better than this with a more sophisticated data structure.</p> <h2 id="beyond-the-notepad-graph-based-deduction-in-fugitive">Beyond the Notepad: Graph-Based Deduction in Fugitive</h2> <h3 id="why-graphs-trump-simple-notepads">Why Graphs Trump Simple Notepads</h3> <p>While a traditional notepad approach (crossing out numbers from 1-42) is intuitive for human players, our graph-based <code class="language-plaintext highlighter-rouge">MarshalNotes</code> offers several advantages for AI implementation:</p> <ol> <li> <p><strong>Sequence Information</strong>: The graph explicitly models the order of hideouts. A simple notepad might tell you that 15 and 20 are possible hideouts, but not which comes first. The graph maintains this crucial sequence information.</p> </li> <li> <p><strong>Constraint Propagation</strong>: When new information is learned, the graph can efficiently propagate these constraints. For example, if we learn the second hideout is 7, this immediately restricts the possible range for the third hideout, which in turn affects the fourth, and so on. A simple notepad struggles to represent these cascading effects.</p> </li> <li> <p><strong>Sprint Modeling</strong>: The graph can easily incorporate the effects of sprints. If we know a sprint occurred between two hideouts, the graph can represent the expanded range of possibilities, something a basic notepad can’t capture.</p> </li> <li> <p><strong>Efficient Querying</strong>: Want to know all possible locations for the 3rd hideout? In the graph, this is a simple query of nodes at depth 3. With a notepad, you’d need additional data structures or complex logic to maintain this information.</p> </li> <li> <p><strong>Revealing Impossibilities</strong>: As the game progresses, certain hideout sequences become impossible. The graph naturally represents this by removing nodes or edges, while a notepad approach might struggle to identify these implicit impossibilities.</p> </li> </ol> <h3 id="graphing-the-escape-route">Graphing the Escape Route</h3> <p>Let’s break down the key components of our graph-based approach:</p> <ol> <li> <p><strong>Nodes</strong>: Each node in our graph represents a potential hideout location. It’s defined by two values:</p> <ul> <li>Depth: The hideout’s position in the sequence (0 for start, 1 for first hideout, etc.)</li> <li>Value: The numeric location (0-42)</li> </ul> </li> <li> <p><strong>Edges</strong>: An edge between two nodes indicates that it’s possible for the Fugitive to move from one hideout to the next, given the game’s rules and known information.</p> </li> <li> <p><strong>Hideouts Range</strong>: We maintain a 2D array <code class="language-plaintext highlighter-rouge">hideouts_range</code> where <code class="language-plaintext highlighter-rouge">hideouts_range[i][j] = 1</code> means the i-th hideout could potentially be at location j.</p> </li> <li> <p><strong>Graph Consistency</strong>: We ensure that the graph remains consistent with the game rules and known information. This involves removing nodes and edges that become impossible based on new information, and updating the <code class="language-plaintext highlighter-rouge">hideouts_range</code> array accordingly.</p> </li> </ol> <h3 id="building-the-graph">Building the Graph</h3> <p>Let’s walk through how we construct and update this graph as the game progresses:</p> <h4 id="1-initialization">1. Initialization</h4> <p>We start with a single node (0, 0), representing the known starting point.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nc">DiGraph</span><span class="p">()</span>
<span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_node</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">MAX_HAND_SIZE</span><span class="p">,</span> <span class="mi">43</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">int8</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div> <h4 id="2-adding-new-hideouts">2. Adding New Hideouts</h4> <p>When the Fugitive places a new hideout, we expand our graph:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_new_hideout</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n_sprint</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">filtered_vals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">prev_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">new_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span>
    <span class="n">nodes_from_prev_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_depth</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">prev_node</span> <span class="ow">in</span> <span class="n">nodes_from_prev_depth</span><span class="p">:</span>
        <span class="n">prev_value</span> <span class="o">=</span> <span class="n">prev_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_new_value</span> <span class="o">=</span> <span class="n">prev_value</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">max_new_value</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">prev_value</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">n_sprint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">min_new_value</span><span class="p">,</span> <span class="n">max_new_value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">filtered_vals</span><span class="p">:</span> <span class="c1"># Eliminated seen values
</span>                <span class="k">continue</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_depth</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">new_depth</span><span class="p">,</span> <span class="n">new_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div> <p>This method considers:</p> <ul> <li>The previous hideout’s possible locations</li> <li>The number of sprint cards played</li> <li>Any values we know can’t be hideouts (filtered_vals)</li> </ul> <p>It then creates new nodes and edges for all potential new hideout locations.</p> <h4 id="3-eliminating-possibilities">3. Eliminating Possibilities</h4> <p>As the Marshal gains information (through correct guesses or drawn cards), we update our graph:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">eliminate_vals</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_remove</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[:,</span> <span class="n">vals</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">remove_unreachable_nodes</span><span class="p">()</span>
</code></pre></div></div> <p>This removes any nodes that we now know can’t be hideouts and updates our <code class="language-plaintext highlighter-rouge">hideouts_range</code> accordingly.</p> <h4 id="4-revealed-hideouts">4. Revealed Hideouts</h4> <p>When a hideout is revealed (either through a correct guess or the Fugitive reaching location 42), we update our graph to reflect this certain information:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hideout_revealed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hideout</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># Remove all nodes at the given depth except the revealed hideout
</span>    <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">depth</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">hideout</span><span class="p">]</span>
    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_remove</span><span class="p">)</span>

    <span class="c1"># Update hideouts_range for this depth
</span>    <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">depth</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">depth</span><span class="p">,</span> <span class="n">hideout</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Remove unreachable nodes
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">_remove_unreachable_nodes</span><span class="p">()</span>
</code></pre></div></div> <h3 id="maintaining-graph-consistency">Maintaining Graph Consistency</h3> <p>After each update, we call <code class="language-plaintext highlighter-rouge">_remove_unreachable_nodes()</code> to ensure our graph remains consistent:</p> <p>This method performs two crucial cleanup operations (Assuming depth is zero indexed):</p> <ol> <li>Removing nodes unreachable from root. This requires a linear scan of the graph from depth 1 to depth n_hideouts-1 and remove the nodes that are not reachable from the previous depth (i.e. nodes with in-degree of 0).</li> <li>Removing nodes unreachable to the latest hideout (leaf at depth n_hideouts). This requires a linear scan of the graph from depth n_hideouts-2 to depth 0 and remove the nodes that are not reachable to the next hideout (i.e. nodes with out-degree of 0).</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_remove_unreachable_nodes</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="c1"># Remove nodes unreacheable from root
</span>    <span class="k">for</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span><span class="p">):</span>
        <span class="n">nodes_at_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">depth</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_at_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">in_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Remove nodes unreachable to the leaf at depth n_hideouts
</span>    <span class="k">for</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">nodes_at_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">depth</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_at_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">out_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div> <p>This ensures that every node in our graph is part of a valid path from the start to the current game state.</p> <h3 id="conclusion">Conclusion</h3> <p>This graph-based approach to modeling the Marshal’s deductive reasoning in Fugitive showcases the power of applying computer science concepts to game AI. By representing the game state as a directed graph, we create a flexible and efficient way to track complex possibilities and make intelligent decisions.</p> <p>The next time you play Fugitive (or design an AI for a similar deduction game), consider how graph theory might help you model the hidden information and logical constraints. Happy hunting!</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="board-game"/><category term="data-structure"/><category term="algorithm"/><category term="game-theory"/><category term="reinforcement-learning"/><category term="fugitive"/><summary type="html"><![CDATA[Tracking the Fugitive with Graph-Based Deduction]]></summary></entry><entry><title type="html">Gear List 2024</title><link href="https://handasontam.github.io/blog/2024/gear-list/" rel="alternate" type="text/html" title="Gear List 2024"/><published>2024-09-08T15:09:00+00:00</published><updated>2024-09-08T15:09:00+00:00</updated><id>https://handasontam.github.io/blog/2024/gear-list</id><content type="html" xml:base="https://handasontam.github.io/blog/2024/gear-list/"><![CDATA[<p>In recent years, I’ve fully embraced the one-bag travel philosophy, often surprising friends with how little I pack for trips. This approach, while not widely adopted in my home city of Hong Kong, has transformed the way I travel. Going “one-bag” eliminates worries about lost luggage, weight restrictions, or struggling with rolling suitcases on cobblestone streets. It’s both liberating and cost-effective.</p> <p>This gear list is inspired by resources like <a href="https://verber.com/gear2024/">Mark Verber’s annual gear roundup</a>, the <a href="https://www.gossamergear.com/blogs/our-blog/vagabond-pack-italy">Gossamer Gear Italy packing list</a>, and the wealth of knowledge shared in the Reddit <a href="https://reddit.com/r/Ultralight/">Ultralight</a> and <a href="https://reddit.com/r/onebag/">OneBag</a> communities. The items listed here have earned their place as my current favorites. While I haven’t tried every alternative, I’ve conducted extensive research before making purchases and rarely regret my choices. Items in <strong>bold</strong> are standouts that I consider best-in-class.</p> <h2 id="on-person">On Person</h2> <p>Samsung S21FE (177g / 6.4’): With a 4500mAh battery and IP68 rating, this phone serves me well. I’m considering a switch to iPhone in the future for better integration with my Macbook and iPad, as well as to explore Apple’s Intelligence capabilities.</p> <p><strong>Montbell Trail Wallet</strong> (15g): This ultralight wallet, crafted from durable 330D Ballistic nylon, fits perfectly in the shoulder strap pocket of my Gossamer Gear pack. It features dedicated spots for coins and keys. Other lightweight options include the <a href="https://ifyouhave.stores.jp/items/5ecca25a34ef01087a46469e">ifyouhave Wallet 2 (14g)</a> and <a href="https://minimalight.thebase.in/items/43829761">Minimalight Play Wallet (15g)</a>.</p> <p>Victorinox Classic SD (20g): This compact multitool covers most camp tasks without adding significant weight.</p> <h2 id="bags">Bags</h2> <p><strong>Gossamergear Vagabond Jet (2021 version)</strong> (648g / 22.8oz): This versatile 23L pack is my go-to for everyday carry, one-bag travel, and even day hikes when I don’t need my full hiking setup. The laptop compartment is suspended 3 inches from the bottom, providing excellent protection against shocks. After three years of use, it remains in good condition, with only minor stitching issues on the laptop suspension (easily repaired by flipping the bag inside out and sewn back the laptop suspension). The sewn-in shoulder strap pocket is a standout feature, offering convenient storage for a wallet and phone without compromising the bag’s sleek appearance. While some may worry about the top opening collecting rain or debris, I haven’t encountered any issues. The only drawback for me is the slightly long torso length. Overall, it strikes an excellent balance between comfort, organization, and weight. Other solid options include the <a href="https://minimalight.thebase.in/items/85137709">Minimalight ordinary Pac (358g)</a> and <a href="https://www.volpioutdoorgear.com/product-page/falco-1">Volpi Falco (480g)</a>.</p> <p><a href="https://www.decathlon.com.hk/p/%E6%A5%B5%E9%80%9F%E5%81%A5%E8%A1%8C%E8%83%8C%E5%8C%85fh900-14%E5%88%B019-l%E7%9A%84%E5%AE%B9%E9%87%8F-quechua-8503969.html"><strong>Decathlon QUECHUA FH900 19L</strong></a> (14-19L adjustable): An incredibly versatile and affordable daypack. The roll-top design allows you to adjust the volume, and it even has a side zipper for easy access. While it comes with a 2L water bladder, I prefer using the bladder pocket to store a foam seat pad (e.g. the <a href="https://www.decathlon.com.hk/en-HK/p/trekking-camping-foam-seat-trek-pad-grey-orange-forclaz-8493400.html">Decathlon Trekking Foam Seat</a>) for extra comfort. The back pocket, designed for the water bladder, can also accommodate a 13” Macbook (without a sleeve) in a pinch, though caution is advised due to the lack of padding and open top. The mesh side pocket is suitable for small items like a hat but doesn’t secure water bottles effectively.</p> <h2 id="electronics">Electronics</h2> <p>Macbook Pro 13” 2018 (1.37kg): With 16GB RAM and 512 GB SSD. While still functional, I’m considering an upgrade to a Macbook Air with 32GB RAM for improved performance in web browsing, coding, and paper writing. Compute-intensive tasks are offloaded to a Linux server.</p> <p>iPad Pro 12.9” 4th generation: Primarily used for note-taking via GoodNotes.</p> <p>Sony WF-1000XM4 Earbuds: Excellent sound quality and noise cancellation in a compact package, perfect for drowning out airplane noise or working in noisy environments.</p> <p>Nitecore NB10000 Power Bank (150g / 5.29oz): A reliable, lightweight 10,000mAh battery capable of fast-charging most devices. Essential for multi-day trips or heavy phone use while traveling. For more options, check out the <a href="https://docs.google.com/spreadsheets/d/1-AL_bU5yGwcGXiqpIQ8qeoi4_XGkkug8HGxDbnnkkQc/edit?gid=1623186548#gid=1623186548">Batteries Datasheet from ultralightdandy</a>.</p> <p>Nitecore NU20 Headlamp (with shock cord mod, 33g): A simple, lightweight headlamp with a single-button interface. The shock cord mod improves comfort and reduces weight.</p> <h2 id="clothing">Clothing</h2> <p>This section highlights standout clothing items that I highly recommend. I also wear other basic t-shirts and pants not listed here.</p> <p><a href="https://www.sundayafternoons.com/products/sun-guide-cap">Sunday Afternoon Sun Guide Cap</a> (93g): Excellent sun protection. The <a href="https://www.parapack.co/shopheadwear/p/p-cap">Parapack P-cap (28g)</a> is a lighter, more packable alternative. The <a href="https://en.montbell.jp/products/goods/disp.php?product_id=1128716">Montbell Rain Umbrero</a> is another intriguing option I’ve seen on the trails.</p> <p>Zenni Glasses with XTRActive Polarized 1.53: Ordering glasses online from Zenni offers significant savings compared to local opticians. Simply input your prescription and choose your lens type. Note that these lenses may appear slightly gray even indoors. For those in Hong Kong needing a prescription, consider the affordable “Comprehensive Eye Examination” at <a href="https://ocwb.polyu.edu.hk/OptometryClinicWebBooking/">PolyU</a>.</p> <p><strong>Patagonia Capilene Cool Lightweight Shirt</strong> (74g): My go-to base layer for hot and humid conditions. It excels at wicking sweat and dries quickly, making it perfect for Hong Kong’s sweltering summers. For more options, check out this <a href="https://docs.google.com/spreadsheets/d/1pA8ym5gRNhmfyDUdBcTGv14gtyV25XMLpdrpZb0mdxY/edit?gid=0#gid=0">Summer Wear DataSheet</a> created by DeputySean.</p> <p><a href="https://www.uniqlo.com.hk/en_GB/product-detail.html?productCode=u0000000050296">Uniqlo Dry-ex lightweight tee shirt</a>: An affordable alternative to the Patagonia Capilene Cool Lightweight Shirt, though not quite as breathable.</p> <p><a href="https://www.yamatomichi.com/en/products/ul-shirt"><strong>Yamatomichi UL Shirt</strong></a> (91g): Made from 100% ShadowRip Polyester, this ultralight, highly breathable button-up offers excellent sun protection and can double as a wind shirt. These are hard to find outside of Japan unless pre-ordered.</p> <p><strong>Ministry of Supply Hybrid Short Sleeve Seersucker</strong> (Size S, Light Grey): Exceptionally comfortable and breathable for hot weather.</p> <p><strong>Cumulus Primelite Pullover</strong> (180g): An incredibly light and warm down jacket that packs tiny, providing an excellent warmth-to-weight ratio for cool evenings or mountain trips. For alternatives, check out this excellent <a href="https://docs.google.com/spreadsheets/d/1ceVWWwGTdc1KcTkIQFWscILPtA2pbgpq0UQQIq1D6gE/edit?gid=0#gid=0">Down Jacket indicator datasheet</a> created by ormagon_89 in the Reddit Ultralight community.</p> <p><strong>Mountain Hardwear AirMesh Hoodie</strong> (140g): This active insulation piece is a game-changer for high-output activities in cool weather. The mesh side absorbs moisture while the fleece side (made with Teijin Octa fabric) provides warmth. Paired with a wind shirt, it’s all I need for most Hong Kong winters. For more insights, check out this <a href="https://backpackinglight.com/forums/topic/airmesh-teijin-octa-fabric-is-the-most-versatile-fabric-i-have-ever-field-tested/">discussion</a>. Alternatives include <a href="https://www.farpointeog.com/commerce/redirect?productId=6098752f744ed54a8fdebc58&amp;utm_source=customer_notification&amp;utm_medium=email">Farpointe Alpha Cruiser</a>, <a href="https://senchidesigns.com/">Senchi Designs Alpha Hoodie</a>, and <a href="https://www.macpac.co.nz/macpac-mens-nitro-fleece-pullover/115606.html">Macpac Nitro Fleece Pullover</a>.</p> <p><strong>CAYL Light Air Jacket</strong> (98.2g): Made from 12D Pertex Quantum Air fabric (the same as the Mountain Hardwear Kor Airshell), this jacket offers excellent breathability and weather resistance. Its double zipper and armpit vents provide versatile ventilation options rarely found in other wind shirts. Combined with the Mountain Hardwear AirMesh Hoodie, it can handle most Hong Kong winters.</p> <p>Montbell Versalite Rain Jacket (182g): A fully-featured ultralight rain jacket with pit zips for ventilation. It’s proven reliably waterproof through numerous downpours. While not necessary for short hikes in Hong Kong, it’s useful for camping in cold rain or adding extra warmth when combined with the AirMesh/Polartec Alpha Hoodie.</p> <p><a href="https://www.mountainhardwear.com/p/mens-trail-sender-pant-2068021.html"><strong>Mountain Hardwear Trail Sender Pant</strong></a> (170g): Made of 100% recycled polyester stretch ripstop (the same fabric as Patagonia Terrebonne Joggers), these pants are incredibly light and breathable. They offer a good range of motion despite being only slightly stretchy. These are my go-to pants for Hong Kong summers and hiking. Compared to the Patagonia Terrebonne Joggers, they look less outdoorsy and feature a zip fly and internal drawstring. They’re also much more affordable, especially during sales. For more options, check out this <a href="https://docs.google.com/spreadsheets/d/1pA8ym5gRNhmfyDUdBcTGv14gtyV25XMLpdrpZb0mdxY/edit?gid=1027755927#gid=1027755927">Summer Wear DataSheet</a> created by DeputySean.</p> <p><a href="https://westernrise.com/products/evolution-pant-classic-dune?variant=42139842969783">Western Rise Evolution Pant 2.0</a>: A stylish option suitable for business casual settings, though they may be too warm for Hong Kong summers.</p> <p>Outdoor Research Men’s Ferrosi Pant: Very stretchy and breathable, but not as light as the Trail Sender Pant.</p> <p><strong>Uniqlo Airism Boxer</strong> (20g): Lightweight, breathable, and affordable underwear.</p> <p><strong>Inov-8 Trailfly G270</strong> (Size 9.5): A versatile and durable trail running shoe. I previously used the Altra Lone Peak 5, which was comfortable but less durable than the Trailfly G270.</p> <p>Lems Drifter: Received as a gift, these shoes are very comfortable but not as breathable as I’d hoped. I use them during Hong Kong winters.</p> <p><strong>Luna Venado 2.0 Sandals</strong> (255g, Size 8.5): These minimalist sandals are my daily drivers. They’re comfortable for walking, work as camp shoes, and double as pool shoes when needed. They become very comfortable once you adjust the straps properly.</p> <h2 id="miscellaneous">Miscellaneous</h2> <p><strong>Tiger MMZ K-501 Water Bottle</strong> (190g, 0.5L): Purchased at Bic Camera in Japan, this is likely the lightest 0.5L insulated bottle available. It’s the perfect size for everyday carry and short hikes. After two years of use, it’s still performing excellently.</p> <p><a href="https://www.borahgear.com/stuffsacks.html">Borah Gear 7x11” stuff sack</a> (5g): Used for storing the Nitecore NB10000, NU20, and USB cable.</p> <p><a href="https://amazon.com/Sea-Summit-Travel-Pocket-Laundry/dp/B002BO60JI">Sea to Summit laundry soap flakes</a>: Useful for washing clothes in hostels without laundry facilities. TSA carry-on compliant, though it doesn’t lather much, and I’m unsure of its effectiveness.</p> <p><a href="https://www.outdoorline.sk/en/trekking-poles/fizan-compact-trekking-poles?search_query=Fizan+compact&amp;results=6#/20-color-red">FIZAN Compact Trekking Poles</a> (158g * 2): Affordable and lightweight trekking poles.</p> <p>Sea to Summit Head net (21g): I haven’t found this particularly useful in Hong Kong.</p> <p>Oral-B iO4: Used for 2 years, very reliable. Purchase from US Amazon during Black Friday sales. Swap the charger to a 220V one from Taobao (the standard voltage in HK) for perfect functionality.</p> <p>Panasonic ES-LV67: Used for over 4 years, very reliable electric shaver.</p> <p><a href="https://seatosummit.com/product/ultra-sil-dry-sack/">Sea to Summit Ultra-Sil Dry Sack</a>: Used for packing clothes during travel or storing wet swimwear after swimming.</p> <h2 id="backpacking-gear">Backpacking Gear</h2> <h3 id="bags-1">Bags</h3> <p><strong>LiteAF Ultra200 Curve 40L</strong>: For longer trips and backpacking adventures, this ultralight pack is my choice. The Ultra200 fabric offers an excellent strength-to-weight ratio, and the frame provides comfort for heavier loads.</p> <p>Nylofume Pack Liner Bags: From LiteSmith, weighing 25.9g.</p> <h3 id="sleep-system">Sleep System</h3> <p><strong>Enlightened Equipment Enigma 30°F</strong> (-1°C) Quilt: This 850 fill power down quilt hits the sweet spot for warmth, weight, and versatility. The 10D fabric keeps it ultralight without sacrificing durability.</p> <p><strong>Sea to Summit Aeros Premium Pillow</strong> (113g / 4oz): A good night’s sleep is worth the extra weight. This inflatable pillow packs tiny but provides excellent comfort and support.</p> <p>Sea to Summit UltralightAir Insulated Pad (479g): With an R-value of 3.1, this pad offers a good balance of warmth and comfort. Unfortunately, I’ve developed a slow leak that I haven’t been able to locate yet.</p> <p>Nemo Switchback (Cut to half-length, ~210g): At 91.5cm for 7 pieces, this pad provides insulation where you need it most. You don’t need it above the neck (the pillow is enough) or below the thighs (your backpack or a seating pad can be used). Best of all, you never have to worry about air leaks.</p> <p><a href="https://www.gossamergear.com/products/thinlight-foam-pad?variant=30497164620"><strong>Gossamer Gear Thinlight foam pad - 1/8”</strong></a> (76g): Measures 19 x 59 inches.</p> <h3 id="shelter">Shelter</h3> <p><strong>Durston X-Mid 2P</strong>: An incredibly well-designed lightweight trekking pole tent. It offers excellent storm protection and livable space for its weight.</p> <h3 id="cooking-system">Cooking System</h3> <p><strong>Evernew Titanium 1300ml Pot</strong> (130g): The wide, shallow design is perfect for alcohol stoves and great for melting snow. The thin titanium walls conduct heat efficiently.</p> <p><strong>Trail Designs Sidewinder Ti-Tri with Kojin Stove</strong>: A versatile, ultralight cooking system that works with multiple fuel types. The Kojin alcohol stove is particularly efficient and user-friendly. I previously used a Trangia stove (14.3cm width * 6.5cm height) but it broke.</p> <p><a href="https://www.rei.com/product/782241/sea-to-summit-alpha-light-spoon-long">Sea to Summit Alpha Light Long Spoon</a> (12g) and <a href="https://www.moosejaw.com/product/sea-to-summit-alpha-light-long-handled-spork_10225937">Spork</a> (12g): Lightweight, durable utensils that reach the bottom of freeze-dried meal bags without getting your hands messy.</p> <p><strong>Bic MiniLighter</strong> (12g): Can be purchased from 7-11.</p> <p>I hope this gear list provides inspiration for your own ultralight and one-bag adventures! Feel free to reach out if you have any questions about specific items or want to share your own favorite gear.</p>]]></content><author><name></name></author><category term="gear-reviews"/><category term="gear"/><category term="ultralight"/><category term="onebag"/><category term="travel"/><summary type="html"><![CDATA[A curated selection of my favorite ultralight and one-bag travel gear]]></summary></entry><entry><title type="html">Solution to the 2024 August Jane Street Puzzles</title><link href="https://handasontam.github.io/blog/2024/js-202408/" rel="alternate" type="text/html" title="Solution to the 2024 August Jane Street Puzzles"/><published>2024-09-01T15:09:00+00:00</published><updated>2024-09-01T15:09:00+00:00</updated><id>https://handasontam.github.io/blog/2024/js-202408</id><content type="html" xml:base="https://handasontam.github.io/blog/2024/js-202408/"><![CDATA[<p>Puzzle link: <a href="https://www.janestreet.com/puzzles/tree-edge-triage-index/">https://www.janestreet.com/puzzles/tree-edge-triage-index/</a></p> <blockquote> <p>Aaron and Beren are playing a game on an infinite complete binary tree. At the beginning of the game, every edge of the tree is independently labeled A with probability p and B otherwise. Both players are able to inspect all of these labels somehow. Then, starting with Aaron at the root of the tree, the players alternate turns moving a shared token down the tree (each turn the active player selects from the two descendants of the current node and moves the token along the edge to that node). If the token ever traverses an edge labeled B, Beren wins the game. Otherwise, Aaron wins. To make this precise, we can add the following step to the start of the game: after the edges are labeled and inspected, Beren is allowed to name any positive integer N. Aaron wins if the first N edges traversed by the token are all labeled A, Beren wins if any of them are labeled B.</p> <p>An example game is in the picture above: after the labeling, Aaron chooses to go left to avoid immediate defeat, but after Beren goes right Aaron is doomed to choose one of two B paths and Beren wins.</p> <p>What is the infimum of the set of all probabilities p for which Aaron has a nonzero probability of winning the game? Give your answer in exact terms.</p> </blockquote> <p>My solution:</p> \[\begin{align} P(\text{A wins at A's turn}) &amp;= 1 - P(\text{A loses at A's turn}) \\ &amp;= 1 - ((1-p) * 1 + p * P(\text{A loses at B's turn}))^2 \\ &amp;= 1 - (1 - p + p * P(\text{A loses at B's turn}))^2 \\ &amp;= 1 - (1 - p + p * (1-P(\text{A wins at B's turn})))^2 \\ &amp;= 1 - (1 - p + p * (1-(p*P(\text{A wins at A's turn}))^2))^2 \\ \end{align}\] <p>If we let \(P(\text{A wins at A's turn})\) be \(x\), we have:</p> \[x = 1 - (1 - p + p * (1 - (p * x)^2))^2\] <p>Rearranging and simplifying, we have:</p> \[x = 2 p^3 x^2 - p^6 x^4\] <p>The infimum of the set of all probabilities p for which x &gt; 0 can be solved using algebra sofware.</p> \[p = \frac{3}{2 \cdot 2^{2/3}} \approx 0.945, \quad x=\frac{8}{9} \approx 0.889\]]]></content><author><name></name></author><category term="puzzles"/><category term="puzzles"/><summary type="html"><![CDATA[Solution to the 2024 August Jane Street Puzzles]]></summary></entry><entry><title type="html">Solution to the 2024 April Jane Street Puzzles</title><link href="https://handasontam.github.io/blog/2024/js-202404/" rel="alternate" type="text/html" title="Solution to the 2024 April Jane Street Puzzles"/><published>2024-05-01T15:09:00+00:00</published><updated>2024-05-01T15:09:00+00:00</updated><id>https://handasontam.github.io/blog/2024/js-202404</id><content type="html" xml:base="https://handasontam.github.io/blog/2024/js-202404/"><![CDATA[<p>Puzzle link: <a href="https://www.janestreet.com/puzzles/robot-capture-the-flag-index/">https://www.janestreet.com/puzzles/robot-capture-the-flag-index/</a></p> <blockquote> <p>Two robots, Aaron and Erin, have made it to this year’s final! Initially they are situated at the center of a unit circle. A flag is placed somewhere inside the circle, at a location chosen uniformly at random. Once the flag is placed, Aaron is able to deduce its distance to the flag, and Erin is only able to deduce its direction to the flag. (Equivalently: if (r, θ) are the polar coordinates of the flag’s location, Aaron is told r and Erin is told θ.)</p> <p>Both robots are allowed to make a single move after the flag is placed, if they wish. Any move they make is without knowledge of what the other robot is doing. (And they may not move outside the circle.)</p> <p>Whichever robot is closer to the flag after these moves captures the flag and is declared the winner!</p> <p>During the preliminaries it was discovered that Erin is programmed to play a fixed distance along the detected angle θ. Assuming otherwise optimal play by both robots, can you determine the probability that Aaron will win? (Please express your answer to 10 decimal places.)</p> </blockquote> <h2 id="solution-approach">Solution Approach</h2> <p>To solve this puzzle, we’ll follow these steps:</p> <ol> <li>Determine Aaron’s optimal strategy.</li> <li>Calculate Aaron’s win probability as a function of Erin’s fixed distance.</li> <li>Find Erin’s optimal fixed distance.</li> <li>Compute the final win probabilities.</li> </ol> <h3 id="1-aarons-optimal-strategy">1. Aaron’s Optimal Strategy</h3> <p>Let’s define some variables:</p> <ul> <li>\(r_E\): Erin’s fixed movement distance</li> <li>\(r\): The actual distance to the flag (known to Aaron)</li> <li>\(r_A(r)\): Aaron’s chosen movement distance</li> <li>\(\theta_A(r)\): Aaron’s chosen movement angle</li> </ul> <p>Since Aaron doesn’t know the flag’s direction, his best strategy is to choose \(\theta_A(r)\) uniformly at random: \(\theta_A(r) \sim U(0, 2\pi)\).</p> <p>To win, Aaron must end up closer to the flag than Erin. This occurs when his final position falls within a circle centered at the flag’s location, with radius \(\lvert r_E - r\rvert\).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/js-202404-0.png" sizes="95vw"/> <img src="/assets/img/js-202404-0.png" class="img-fluid rounded z-depth-1" width="40%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>To maximize his chances, Aaron should choose \(r_A\) such that it forms a right triangle with \(\lvert r_E-r\rvert\) and \(r\):</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/js-202404-1.png" sizes="95vw"/> <img src="/assets/img/js-202404-1.png" class="img-fluid rounded z-depth-1" width="40%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Why? Imagine \(r_A\) rotates around the origin, comparing to other choice of \(r_A\), this choice ensures the locus enters this region earliest and leaving it latest, and thus maximizing the probability Aaron stays in this region. Therefore, by the Pythagorean theorem, we have: \(r_A(r) = \sqrt{r^2-\lvert r_E-r\rvert^2} = \sqrt{r_E(2r-r_E)}\) when \(r^2 \geq \lvert r_E-r\rvert^2\), or equivalently, \(r \geq \frac{r_E}{2}\). What if \(r &lt; \frac{r_E}{2}\)? In this case, Aaron gurantees a win by staying at the center (i.e. choosing \(r_A = 0\)), as his distance to the flag (\(r\)) will always be less than Erin’s (\(\lvert r_E-r\rvert\)). Now, we have successfully derived the best response of Aaron:</p> \[r_A(r) = \begin{cases} \sqrt{r_E(2r-r_E)} &amp; \text{if } r \geq \frac{r_E}{2} \\ 0 &amp; \text{if } r &lt; \frac{r_E}{2} \end{cases}\] <h3 id="2-aarons-win-probability">2. Aaron’s Win Probability</h3> <p>Given Aaron’s optimal strategy, we can express his win probability as a function of \(r_E\):</p> \[\begin{align} P(\text{Aaron wins}) &amp;= \int_{r_E/2}^{1} \frac{2r}{π} \arccos\left(\frac{\sqrt{r_E (2r - r_E)}}{r}\right) dr + \int_{0}^{r_E/2} 2r dr \\ &amp;= \int_{r_E/2}^{1} \frac{2r}{π} \arccos\left(\frac{\sqrt{r_E (2r - r_E)}}{r}\right) dr + \frac{r_E^2}{4} \end{align}\] <h3 id="3-erins-optimal-strategy">3. Erin’s Optimal Strategy</h3> <p>Knowing Aaron’s win probability, Erin would choose \(r_E\) to minimize Aaron’s win probability. At this point, we can use numerical solver to minimize the above function with respect to \(r_E\). (Side note: I initially spent a considerable amount of time attempting to solve this problem analytically. After several unsuccessful attempts, I realized that a closed-form solution wasn’t necessary for this particular problem. This experience serves as a reminder that sometimes, recognizing when to pivot to numerical methods can save time and effort in problem-solving.)</p> <h3 id="4-numerical-solution">4. Numerical Solution</h3> <p>Using Python with SciPy for numerical integration and optimization:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">scipy.integrate</span> <span class="k">as</span> <span class="n">integrate</span>
<span class="kn">import</span> <span class="n">scipy.special</span> <span class="k">as</span> <span class="n">special</span>
<span class="kn">from</span> <span class="n">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize_scalar</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">r_1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">integrate</span><span class="p">.</span><span class="nf">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">arccos</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">r_1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">-</span> <span class="n">r_1</span><span class="p">))</span><span class="o">/</span><span class="n">r</span><span class="p">),</span> <span class="n">r_1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">epsabs</span><span class="o">=</span><span class="mf">1e-30</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1e-30</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">r_1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>

<span class="n">res</span> <span class="o">=</span> <span class="nf">minimize_scalar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">bounded</span><span class="sh">'</span><span class="p">)</span>


<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Erwin should choose r_1 = </span><span class="sh">"</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 0.5013067075684123
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The best response of Aaron is to choose r_2 = 0 if r &lt; (r_1)/2 and choose r_2 = sqrt(r_1 * (2r - r_1)) if (r_1)/2 &lt; r &lt; 1</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Erwin</span><span class="sh">'</span><span class="s">s win probability is </span><span class="sh">"</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">res</span><span class="p">.</span><span class="n">fun</span><span class="p">)</span>  <span class="c1"># 0.8338135135259306
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Aaron</span><span class="sh">'</span><span class="s">s win probability is </span><span class="sh">"</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">fun</span><span class="p">)</span>  <span class="c1"># 0.16618648647406942
</span></code></pre></div></div> <p>The result shows that at equilibrium, Erin would chooses a fixed \(r_E \approx 0.5013\), Aaron will choose</p> \[r_A = \begin{cases} 0 &amp; \text{if } r &lt; \frac{r_E}{2} \\ \sqrt{r_E (2r - r_E)} &amp; \text{if } \frac{r_E}{2} &lt; r &lt; 1 \end{cases}\] <p>And the probability that Aaron wins is \(\approx 0.1662\).</p>]]></content><author><name></name></author><category term="puzzles"/><category term="puzzles"/><summary type="html"><![CDATA[Solution to the 2024 April Jane Street Puzzles]]></summary></entry></feed>