<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://handasontam.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://handasontam.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-18T08:12:01+00:00</updated><id>https://handasontam.github.io/feed.xml</id><title type="html">Handason’s Blog</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Solution to the 2024 August Jane Street Puzzles</title><link href="https://handasontam.github.io/blog/2024/js-202409/" rel="alternate" type="text/html" title="Solution to the 2024 August Jane Street Puzzles"/><published>2024-10-01T15:09:00+00:00</published><updated>2024-10-01T15:09:00+00:00</updated><id>https://handasontam.github.io/blog/2024/js-202409</id><content type="html" xml:base="https://handasontam.github.io/blog/2024/js-202409/"><![CDATA[<p>Puzzle link: <a href="https://www.janestreet.com/puzzles/tree-edge-triage-index/">https://www.janestreet.com/puzzles/tree-edge-triage-index/</a></p> <p>This month’s puzzle is relatively easy.</p> \[\begin{align} P(\text{A wins at A's turn}) &amp;= 1 - P(\text{A loses at A's turn}) \\ &amp;= 1 - ((1-p) * 1 + p * P(\text{A loses at B's turn}))^2 \\ &amp;= 1 - (1 - p + p * P(\text{A loses at B's turn}))^2 \\ &amp;= 1 - (1 - p + p * (1-P(\text{A wins at B's turn})))^2 \\ &amp;= 1 - (1 - p + p * (1-(p*P(\text{A wins at A's turn}))^2))^2 \\ \end{align}\] <p>If we let \(P(\text{A wins at A's turn})\) be \(x\), we have:</p> \[x = 1 - (1 - p + p * (1 - (p * x)^2))^2\] <p>Rearranging and simplifying, we have:</p> \[x = 2 p^3 x^2 - p^6 x^4\] <p>The infimum of the set of all probabilities p for which x &gt; 0 can be solved using algebra sofware.</p> \[p = \frac{3}{2 \cdot 2^{2/3}} \approx 0.945, \quad x=\frac{8}{9} \approx 0.889\]]]></content><author><name></name></author><category term="puzzles"/><category term="puzzles"/><summary type="html"><![CDATA[Solution to the 2024 August Jane Street Puzzles]]></summary></entry><entry><title type="html">Fugitive #1: Tracking the Fugitive with Graph-Based Deduction</title><link href="https://handasontam.github.io/blog/2024/fugitive-marshal/" rel="alternate" type="text/html" title="Fugitive #1: Tracking the Fugitive with Graph-Based Deduction"/><published>2024-09-20T15:09:00+00:00</published><updated>2024-09-20T15:09:00+00:00</updated><id>https://handasontam.github.io/blog/2024/fugitive-marshal</id><content type="html" xml:base="https://handasontam.github.io/blog/2024/fugitive-marshal/"><![CDATA[<p>In the realm of two-player deduction games, “Fugitive” stands out as a thrilling cat-and-mouse chase. One player, the Fugitive, tries to escape by moving through a series of hidden locations, while the other player, the Marshal, attempts to deduce and uncover these hideouts. Today, we’ll dive into a fascinating AI implementation that brings the Marshal’s deductive reasoning to life using graph theory.</p> <p>I recently had the pleasure of playing Fugitive with friends and found it to be an engaging game of strategy and deduction. As someone who enjoys analyzing optimal strategies in games, I was naturally drawn to exploring the strategic depths of Fugitive.</p> <p>In this series of posts, I’ll model the game using graph theory and reinforcement learning techniques. My goal is to uncover optimal strategies for both players and gain insights into the game’s balance.</p> <p>Interestingly, when researching online strategies, I discovered a divide in player opinions regarding which role has an advantage. Some players claim the Marshal can never win (as discussed <a href="https://boardgamegeek.com/thread/2997124/cant-win-as-marshal">here</a>), while others question if the Marshal can lose at all (see <a href="https://boardgamegeek.com/thread/1757632/can-the-marshal-lose">this thread</a>). This disparity in experiences adds an intriguing dimension to our analysis.</p> <h3 id="game-overview">Game Overview</h3> <p>Fugitive is a two-player card game where one player takes on the role of a Fugitive trying to escape, while the other plays as the Marshal attempting to catch them. The game uses a deck of 43 numbered cards (0-42) representing potential hideouts. The Fugitive wins by playing the #42 card, signifying a successful escape, while the Marshal wins by uncovering all of the Fugitive’s hideouts before they can escape.</p> <p>Players take turns, with the Fugitive starting at hideout 0. The Fugitive establishes hideouts by playing cards face-down in ascending order. Each new hideout must be numbered within 1, 2, or 3 of the previous one. To cover larger distances, the Fugitive can “Sprint” by placing additional cards underneath a hideout. These sprint cards have values (+1 or +2) that allow the Fugitive to jump further than the usual 3-card limit.</p> <p>The Marshal attempts to guess and reveal these hideouts. The game’s tension builds as the Fugitive tries to outmaneuver the Marshal, using special “Sprint” moves to cover larger distances, while the Marshal uses deduction and strategy to close in on their target.</p> <h3 id="research-questions">Research Questions</h3> <p>Through this series, we aim to answer the following questions:</p> <ol> <li>How can we optimally take and update notes as the Marshal?</li> <li>What are the optimal strategies for both players? <ul> <li>For the Marshal: <ul> <li>Which deck should the Marshal draw from? Is drawing exclusively from a higher pile to create a ‘roadblock’ useful?</li> <li>Which numbers should the Marshal guess?</li> <li>Should the Marshal guess more than one number?</li> <li>Should the Marshal aim to win by manhunt or by uncovering all hideouts before the Fugitive escapes?</li> </ul> </li> <li>For the Fugitive: <ul> <li>Which hideouts should the Fugitive establish?</li> <li>Which sprints should the Fugitive use?</li> <li>Does bluffing help?</li> </ul> </li> </ul> </li> <li>What are the winning probabilities for both players if they play optimally? This will help us determine if the game is balanced.</li> </ol> <p>In this post, we’ll tackle the first question by exploring an advanced note-taking system for the Marshal using graph-based deduction.</p> <h3 id="the-marshals-dilemma">The Marshal’s Dilemma</h3> <p>Imagine you’re the Marshal. You know the Fugitive started at location 0 and is making their way towards location 42. Each turn, they place a new hideout card face-down, occasionally “sprinting” by adding extra cards to cover larger distances. Your job? Guess these hideouts before the Fugitive reaches their final escape.</p> <p>The challenge lies in efficiently tracking all possible locations for each hideout based on the limited information you receive. This is where our <code class="language-plaintext highlighter-rouge">MarshalNotes</code> class comes in, leveraging a directed graph to model the Marshal’s deductions.</p> <p>This approach will also be useful when we implement the action mask in the reinforcement learning setting for filtering out illegal actions. Consider the action space for the Marshal’s guess:</p> <ol> <li> <p>The Marshal should only guess numbers within the possible range of hideouts. For example, if the Fugitive plays 2 hideouts without sprinting at the start of the game, the Marshal should not guess any number larger than 6.</p> </li> <li> <p>The Marshal must not guess numbers that are in their hand, have already been revealed as hideouts, or used as sprints.</p> </li> <li> <p>The Marshal can avoid guessing numbers that have already been guessed, with one caveat: A wrong guess only reveals that the number is not a hideout among those already placed. It could still be a future hideout.</p> </li> </ol> <p>As the game progresses, the Marshal must keep track of the possible range for each hideout and update this information based on guesses, revealed cards, and drawn cards.</p> <p>Based on the above considerations, the official board game provided a Marshal’s notepad (<a href="https://apps.apple.com/hk/app/fugitive-notepad/id1135595567">example</a>), which consists of a grid of 41 numbers, and the marshal can mark the number that has been known not to be a hideout. This helps the marshal to keep track of the potential hideouts. However, we can do much better than this with a more sophisticated data structure.</p> <h2 id="beyond-the-notepad-graph-based-deduction-in-fugitive">Beyond the Notepad: Graph-Based Deduction in Fugitive</h2> <h3 id="why-graphs-trump-simple-notepads">Why Graphs Trump Simple Notepads</h3> <p>While a traditional notepad approach (crossing out numbers from 1-42) is intuitive for human players, our graph-based <code class="language-plaintext highlighter-rouge">MarshalNotes</code> offers several advantages for AI implementation:</p> <ol> <li> <p><strong>Sequence Information</strong>: The graph explicitly models the order of hideouts. A simple notepad might tell you that 15 and 20 are possible hideouts, but not which comes first. The graph maintains this crucial sequence information.</p> </li> <li> <p><strong>Constraint Propagation</strong>: When new information is learned, the graph can efficiently propagate these constraints. For example, if we learn the second hideout is 7, this immediately restricts the possible range for the third hideout, which in turn affects the fourth, and so on. A simple notepad struggles to represent these cascading effects.</p> </li> <li> <p><strong>Sprint Modeling</strong>: The graph can easily incorporate the effects of sprints. If we know a sprint occurred between two hideouts, the graph can represent the expanded range of possibilities, something a basic notepad can’t capture.</p> </li> <li> <p><strong>Efficient Querying</strong>: Want to know all possible locations for the 3rd hideout? In the graph, this is a simple query of nodes at depth 3. With a notepad, you’d need additional data structures or complex logic to maintain this information.</p> </li> <li> <p><strong>Revealing Impossibilities</strong>: As the game progresses, certain hideout sequences become impossible. The graph naturally represents this by removing nodes or edges, while a notepad approach might struggle to identify these implicit impossibilities.</p> </li> </ol> <h3 id="graphing-the-escape-route">Graphing the Escape Route</h3> <p>Let’s break down the key components of our graph-based approach:</p> <ol> <li><strong>Nodes</strong>: Each node in our graph represents a potential hideout location. It’s defined by two values: <ul> <li>Depth: The hideout’s position in the sequence (0 for start, 1 for first hideout, etc.)</li> <li>Value: The numeric location (0-42)</li> </ul> </li> <li> <p><strong>Edges</strong>: An edge between two nodes indicates that it’s possible for the Fugitive to move from one hideout to the next, given the game’s rules and known information.</p> </li> <li> <p><strong>Hideouts Range</strong>: We maintain a 2D array <code class="language-plaintext highlighter-rouge">hideouts_range</code> where <code class="language-plaintext highlighter-rouge">hideouts_range[i][j] = 1</code> means the i-th hideout could potentially be at location j.</p> </li> <li><strong>Graph Consistency</strong>: We ensure that the graph remains consistent with the game rules and known information. This involves removing nodes and edges that become impossible based on new information, and updating the <code class="language-plaintext highlighter-rouge">hideouts_range</code> array accordingly.</li> </ol> <h3 id="building-the-graph">Building the Graph</h3> <p>Let’s walk through how we construct and update this graph as the game progresses:</p> <h4 id="1-initialization">1. Initialization</h4> <p>We start with a single node (0, 0), representing the known starting point.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nc">DiGraph</span><span class="p">()</span>
<span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_node</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">MAX_HAND_SIZE</span><span class="p">,</span> <span class="mi">43</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">int8</span><span class="p">)</span>
<span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div> <h4 id="2-adding-new-hideouts">2. Adding New Hideouts</h4> <p>When the Fugitive places a new hideout, we expand our graph:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_new_hideout</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n_sprint</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">filtered_vals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">prev_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">new_depth</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span>
    <span class="n">nodes_from_prev_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_depth</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">prev_node</span> <span class="ow">in</span> <span class="n">nodes_from_prev_depth</span><span class="p">:</span>
        <span class="n">prev_value</span> <span class="o">=</span> <span class="n">prev_node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_new_value</span> <span class="o">=</span> <span class="n">prev_value</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">max_new_value</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">prev_value</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">n_sprint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">min_new_value</span><span class="p">,</span> <span class="n">max_new_value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_value</span> <span class="ow">in</span> <span class="n">filtered_vals</span><span class="p">:</span> <span class="c1"># Eliminated seen values
</span>                <span class="k">continue</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_depth</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">add_edge</span><span class="p">(</span><span class="n">prev_node</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">new_depth</span><span class="p">,</span> <span class="n">new_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div> <p>This method considers:</p> <ul> <li>The previous hideout’s possible locations</li> <li>The number of sprint cards played</li> <li>Any values we know can’t be hideouts (filtered_vals)</li> </ul> <p>It then creates new nodes and edges for all potential new hideout locations.</p> <h4 id="3-eliminating-possibilities">3. Eliminating Possibilities</h4> <p>As the Marshal gains information (through correct guesses or drawn cards), we update our graph:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">eliminate_vals</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_remove</span><span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[:,</span> <span class="n">vals</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">remove_unreachable_nodes</span><span class="p">()</span>
</code></pre></div></div> <p>This removes any nodes that we now know can’t be hideouts and updates our <code class="language-plaintext highlighter-rouge">hideouts_range</code> accordingly.</p> <h4 id="4-revealed-hideouts">4. Revealed Hideouts</h4> <p>When a hideout is revealed (either through a correct guess or the Fugitive reaching location 42), we update our graph to reflect this certain information:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hideout_revealed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hideout</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="c1"># Remove all nodes at the given depth except the revealed hideout
</span>    <span class="n">nodes_to_remove</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">depth</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">hideout</span><span class="p">]</span>
    <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_nodes_from</span><span class="p">(</span><span class="n">nodes_to_remove</span><span class="p">)</span>
    
    <span class="c1"># Update hideouts_range for this depth
</span>    <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">depth</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">depth</span><span class="p">,</span> <span class="n">hideout</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># Remove unreachable nodes
</span>    <span class="n">self</span><span class="p">.</span><span class="nf">_remove_unreachable_nodes</span><span class="p">()</span>
</code></pre></div></div> <h3 id="maintaining-graph-consistency">Maintaining Graph Consistency</h3> <p>After each update, we call <code class="language-plaintext highlighter-rouge">_remove_unreachable_nodes()</code> to ensure our graph remains consistent:</p> <p>This method performs two crucial cleanup operations (Assuming depth is zero indexed):</p> <ol> <li>Removing nodes unreachable from root. This requires a linear scan of the graph from depth 1 to depth n_hideouts-1 and remove the nodes that are not reachable from the previous depth (i.e. nodes with in-degree of 0).</li> <li>Removing nodes unreachable to the latest hideout (leaf at depth n_hideouts). This requires a linear scan of the graph from depth n_hideouts-2 to depth 0 and remove the nodes that are not reachable to the next hideout (i.e. nodes with out-degree of 0).</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_remove_unreachable_nodes</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="c1"># Remove nodes unreacheable from root
</span>    <span class="k">for</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span><span class="p">):</span>
        <span class="n">nodes_at_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">depth</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_at_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">in_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Remove nodes unreachable to the leaf at depth n_hideouts
</span>    <span class="k">for</span> <span class="n">depth</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n_hideouts</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">nodes_at_depth</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">depth</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_at_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">out_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">graph</span><span class="p">.</span><span class="nf">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">self</span><span class="p">.</span><span class="n">hideouts_range</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div> <p>This ensures that every node in our graph is part of a valid path from the start to the current game state.</p> <h3 id="conclusion">Conclusion</h3> <p>This graph-based approach to modeling the Marshal’s deductive reasoning in Fugitive showcases the power of applying computer science concepts to game AI. By representing the game state as a directed graph, we create a flexible and efficient way to track complex possibilities and make intelligent decisions.</p> <p>The next time you play Fugitive (or design an AI for a similar deduction game), consider how graph theory might help you model the hidden information and logical constraints. Happy hunting!</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="board-game"/><category term="data-structure"/><category term="algorithm"/><category term="game-theory"/><category term="reinforcement-learning"/><category term="fugitive"/><summary type="html"><![CDATA[Tracking the Fugitive with Graph-Based Deduction]]></summary></entry></feed>